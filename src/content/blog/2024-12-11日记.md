---
title: "日记"
description: "这是2024年12月11日的日记"
pubDate: "Dec 11 2024"
image: "/head_pic/Sigewinne_4.webp"
categories:
  - life
tags:
  - 日记
---

## 上午
今天不用考试，所以是个补专题的好日子。

### <a href = "https://www.luogu.com.cn/problem/P4363" target = "Blank">P4363 [九省联考 2018] 一双木棋 chess</a>  
我们先来看看一组我搓的样例：  
<img src = "/pic_in_blog/2024-12-11日记/初始.webp">  
这是初始状态，红色的格子表示下一步能选什么。  
<img src = "/pic_in_blog/2024-12-11日记/1.webp">  
这是选了一个的状态  
<img src = "/pic_in_blog/2024-12-11日记/2.webp">  
这是选了两个的状态  
我们可以发现，在题目的限制下，黑色的轮廓线总是向上或者向右，如初始状态下就是 `上上上上右右右右`，第二种就是 `上上上右上右右右` 。这能发现什么，这不就能状压了吗？  
我们设 $dp_{sta}$ 表示状态为 $sta$ 时的答案。其中：$sta$ 在二进制下的第 $i$ 位为 `1` 表示这个轮廓线为上。那么初始状态为 `((1 << n) - 1) << m` 。那么如何转移呢？先暂且设下一个状态为 $nxt$ ，当前坐标为 $(x,y)$ ，那么有：
$$
dp_{nxt} = \begin{cases}
dp_{sta} + a_{x,y} & \text{该菲菲取} \\
dp_{sta} - b_{x,y} & \text{该牛牛取} \\
\end{cases}
$$
然后重要的就是怎么求 $nxt$ 。我们看：这个点能取，也就是说他左上的轮廓线是 `上右` 。到状态里就是 `xxx..10..xxx` 。那我么怎么判断呢？很简单，只需要异或 `0b11`。当 `(sta >> i) ^ 0b11 = 1` 时，就说明满足条件了，我们就可以进行转移，$nxt$ 就是 `sta & (0b11 << i)` 。而结束状态就是 `(1 << m) - 1` 。但是我们怎么判断当前是该该菲菲取还是该牛牛取呢？一种是写判断小函数，但是我太懒也太蒻了，写不来，于是我写的记搜，把该谁取放在形参里传下去就可以了。  
核心代码：
```cpp
int dfs(int sta,int wh)//wh就是记录该谁取
{
    if (dp[sta] != inf)
        return dp[sta];
    dp[sta] = wh ? -inf : inf;
    int x = n,y = 0;
    for (int i = 0; i < n + m - 1; i++)
    {
        if ((1 << i) & sta)//这个if就是记录当前坐标的
            x --;
        else
            y ++;
        if (((sta >> i) & 0b11) != 1)//如果不可以转移
            continue;
        if (wh)//题解里说的转移
            dp[sta] = max(dp[sta],dfs(sta ^ (0b11 << i),wh ^ 1) + a[x][y]);
        else
            dp[sta] = min(dp[sta],dfs(sta ^ (0b11 << i),wh ^ 1) - b[x][y]);
    }
    return dp[sta];
}
```

### <a href = "https://www.luogu.com.cn/problem/UVA12983" target = "_blank">UVA12983 The Battle of Chibi</a>
<a href = "https://www.luogu.com.cn/article/birofcz1" target = "_blank">solution</a>  
我们先想朴素的状态和转移：设 $dp_{i,j}$ 表示以 $a_i$ 结尾的长度为 $j$ 的子序列个数。那么有 $dp_{i,j} = \sum\limits_{k \in [1,i),a_k < a_i}dp_{k - 1,j - 1}$ 。但是我们发现：枚举状态就有 $\mathcal{O}(nm)$ 的，而转移又有 $\mathcal{O}(n)$ ，合起来就是 $\mathcal{O}(n^2m)$ ，这明显过不了啊。  
我们考虑优化：我们发现 $dp_{i,j}$ 都是由 $dp_{x,j - 1}$ 转移而来的，所以最外层循环可以是 $j$ 。然后我们可以想到前缀和：以 $a_i$ 为下标，记录前 $i - 1$ 个数中 $a_k < a_i$ 的 $dp_{k,j - 1}$ 的前缀和，这个可以用树状数组。但是 $a_i$ 很大，要离散化。那么这样，我们成功的把dp优化到了 $\mathcal{O}(m \times n \log n)$ 。  
核心代码：
```cpp
for (int i = 1; i <= n; i++)
{
    cin >> a[i];
    apr[i] = a[i];
}
sort(apr + 1,apr + n + 1);
len = unique(apr + 1,apr + n + 1) - apr - 1;
memset(dp,0,sizeof dp);
for (int i = 1; i <= n; i++)
    dp[i][1] = 1;
for (int i = 1; i <= n; i++)
    a[i] = bound(a[i]);//bound用来求a[i]在apr[i]里的下标
for (int j = 2; j <= m; j++)
{
    memset(tree,0,sizeof tree);
    for (int i = 1; i <= n; i++)
    {
        dp[i][j] = que(a[i] - 1);//查询前缀和
        upd(a[i],dp[i][j - 1]);//记录dp[k][j - 1]的前缀和
    }
}
int ans = 0;
for (int i = 1; i <= n; i++)
    ans = (ans + dp[i][m]) % mod;
```