---
title: "日记"
description: "这是2024年12月31日的日记"
pubDate: "Dec 30 2024"
image: "/head_pic/原神一周年.webp"
categories:
  - life
tags:
  - 日记
---

我是耐断更王。

至于我为啥又开始更了呢？因为我发现，不把解题思路记下来真的会忘。

因为今天要把所有的没写解题思路的题补上，所以就不分上午下午的了。

### [P10986 [蓝桥杯 2023 国 Python A] 2023](https://www.luogu.com.cn/problem/P10986)

我们看到“恰好”两个字，就想到先推“至少”的情况，再用二项式反演的式子推到“恰好”。

设 $f_m$ 表示至少有 $m$ 个 `2023` 的方案数。我们钦定有 $m$ 个 `2023`，再用[插板法](https://oi-wiki.org/math/combinatorics/combination/#%E6%8F%92%E6%9D%BF%E6%B3%95)，在这些 `2023` 的缝里插入那些乱七八糟的数。因为插入的时候会再凑出一些 `2023`，所以是“至少”。那么，在 $m$ 个 `2023` 中插入 $n - 4m$ 个数的方案是

$$
f_m = \binom{(n - 4m) + (m + 1) - 1}{(n - 4m) - 1}
$$

设 $g_m$ 表示恰好有 $m$ 个 `2023` 的方案数，那么有：

$$
f_m = \sum\limits_{i = m}^{n}\binom{i}{m}g_i
$$

根据二项式反演公式，我们得到：

$$
g_m = \sum\limits_{i = m}^{n}(-1)^{i - m}\binom{i}{m}f_i
$$

那么我们就求得了 $g_m$，就是答案。时间复杂度 $\mathcal{O}(n)$

### [BZOJ2839 集合计数](https://www.luogu.com.cn/problem/P10596)

还是由“至少”转到“恰好”。

设 $f_{k}$ 表示钦定有 $k$ 个相同元素的情况，那么，剩下的 $n - k$ 个元素能够组成 $2^{n - k}$ 个集合，而，这 $2^{n - k}$ 个集合又能够再组成 $2^{2^{n - k}}$ 个集合。那么显然有 

$$
f_{k} = \binom{n}{k}2^{2^{n - k}}
$$

设 $g_{k}$ 表示恰好有 $k$ 个相同元素的情况，那么有：

$$
f_{k} = \sum\limits_{i = k}^{n}\binom{i}{k}g_{i}
$$

反演一下得到：

$$
g_{k} = \sum\limits_{i = k}^{n}(-1)^{i - k}\binom{i}{k}f_{i}
$$

我们就得到了 $g_{k}$。时间复杂度 $\mathcal{O}(n)$。

### [P1450 [HAOI2008] 硬币购物](https://www.luogu.com.cn/problem/P1450)

我们先考虑没有限制的情况：$dp_{i}$ 表示没有限制的情况下买价格为 $i$ 的物品的方案数，容易发现这就是一个完全背包，可以在 $\mathcal{O}(val)$ 的复杂度下预处理，其中 $val$ 表示最大价格。然后接下来考虑限制的情况。发现正着考虑不超过限制的情况不太好做，**正难则反**。  
我们考虑超过限制的情况。超过限制就是第 $i$ 个硬币强制选 $d_{i} + 1$ 个，剩下的依然随便选，那么情况数就是 $dp_{s - (d_{i} + 1) \times c_{i}}$，答案就要减去 $\sum\limits_{i = 1}^{4}dp_{s - (d_{i} + 1) \times c_{i}}$。这是单个硬币超出限制的情况，如果有多个硬币，就得请出我们的容斥原理了。但是，容斥原理的公式要求任意两个集合的交集和并集大小相等，这很明显不相等啊，我们又发现：只有 $4$ 种硬币，那我们直接枚举不就行了吗？无非就是带一个 $16$ 的常数嘛。

核心代码：

```cpp
int ans = dp[s];//dp是预处理好的完全背包
for (int k = 1; k < (1 << 4); k++)
{
    int tmp = s;
    for (int i = 0; i < 4; i++)
        if (k & (1 << i))
            tmp -= (d[i] + 1) * c[i];
    if (tmp >= 0)
        ans += (__builtin_popcount(k) & -1 : 1) * dp[tmp];//容斥
}
```

### [P5505 [JSOI2011] 分特产](https://www.luogu.com.cn/problem/P5505)

还是一道很板的二项式反演。首先设 $f_{i}$ 表示至少有 $i$ 个同学没有拿到特产的方案数，那么有：

$$
f_{i} = \binom{n}{i} \times \prod\limits_{j}^{m}\binom{a_{j} + n - i - 1}{n - i - 1}
$$

后面那坨表示将 $a_{j}$ 个物品分成 $n - i$ 个可空集的方案数，而前面的是因为我们并没有钦定哪几个人没有，所以要乘一个在 $n$ 个人里面选 $i$ 个的方案数。

接下来我们开始反演。设 $g_{i}$ 表示正好有 $i$ 个人没有，那么有反演公式：

$$
g_{i} = \sum\limits_{j = i}^{n}(-1)^{j - i}\binom{j}{i}f_{j}
$$

而我们要让每一个人都拿到，答案就是 $g_{0}$。这样，我们就做完了。时间复杂度 $\mathcal{O}(n)$

### [P6521 [CEOI2010 day2] pin](https://www.luogu.com.cn/problem/P6521)

发现考虑不同的方案数有点难，**正难则反**。  
依然先考虑“至少”。我们设 $cnt_i$ 为至少有 $i$ 位相同的方案数。这个可以用哈希求解。我们设哈希函数：

```cpp
int hsh(char ch){return isdigit(ch) ? ch - '0' : ch - 'a' + 10;}
int hsh(char ch1,char ch2){return hsh(ch1) * 36 + hsh(ch2);}
int hsh(char ch1,char ch2,char ch3)
{return hsh(ch1) * 36 * 36 + hsh(ch2) * 36 + hsh(ch3);}
```

分别用于求解一个字符，两个字符，三个字符的哈希值。很明显，这个哈希函数生成的哈希值不会超过 $6 \times 10 ^ 4$。那么我们记录 $tmp_{i}$ 表示有多少个字符序列的哈希值是 $i$，然后要求解方案数呢，就相当于求解“在 $tmp_{i}$ 个元素里随便取两个不同元素的方案数”，很明显是 $\frac{tmp_{i} \times (tmp_{i} - 1)}{2}$。最后，我们求得了至少有 $i$ 个元素相同的方案数，因为最多有 $4$ 个元素相同，所以我们直接暴力容斥就行。

code:

```cpp
for (int x = 1; x <= 4; x++)//一个字符相同的
{
    memset(tmp,0,sizeof tmp);
    for (int i = 1; i <= n; i++)
        tmp[hsh(s[i][x])] ++;
    for (int i = 0; i <= 6e4; i++)
        cnt[1] += (tmp[i] * (tmp[i] - 1)) >> 1;
}
for (int x = 1; x <= 4; x++)//两个字符相同
{
    for (int y = x + 1; y <= 4; y++)
    {
        memset(tmp,0,sizeof tmp);
        for (int i = 1; i <= n; i++)
            tmp[hsh(s[i][x],s[i][y])] ++;
        for (int i = 0; i <= 6e4; i++)
            cnt[2] += (tmp[i] * (tmp[i] - 1)) >> 1;
    }
}
for (int x = 1; x <= 4; x++)//三个字符相同
{
    for (int y = x + 1; y <= 4; y++)
    {
        for (int z = y + 1; z <= 4; z++)
        {
            memset(tmp,0,sizeof tmp);
            for (int i = 1; i <= n; i++)
                tmp[hsh(s[i][x],s[i][y],s[i][z])] ++;
            for (int i = 0; i <= 6e4; i++)
                cnt[3] += (tmp[i] * (tmp[i] - 1)) >> 1;
        }
    }
}
//以下是暴力容斥
ans[3] = cnt[3];
ans[2] = cnt[2] - 3 * ans[3];
ans[1] = cnt[1] - ans[2] * 2 - ans[3] * 3;
ans[0] = ((n * (n - 1)) >> 1) - ans[1] - ans[2] - ans[3];
printf("%lld",ans[4 - d]);//由于求解的是相同的，所以不同的就是4 - d个
```

### [P10597 BZOJ4665 小 w 的喜糖](https://www.luogu.com.cn/problem/P10597)

依然是正难则反+二项式反演 ~~演都不带演~~

还是从“至少”做起。设 $f_{i}$ 表示至少有 $i$ 个位置相同，$g_{i}$ 表示正好 $i$ 个位置相同。那么有反演：

$$
f_{i} = \sum\limits_{j = n}^{m}\binom{j}{n}g_{j} 
\Longleftrightarrow
g_{i} = \sum\limits_{j = n}^{m}(-1)^{i - n}\binom{j}{n}f_{j}
$$

我们的答案就是 $g_{0}$

现在的问题就在于怎么求 $f_{i}$。发现初始数组的顺序对于答案来说没有影响，那么我们就记录每种颜色的数量并去重，然后开始 dp。设 $dp_{i,j}$ 表示循环到第 $i$ 个颜色，钦定有 $j$ 个元素相同的方案数。那么有

$$
dp_{i,j} = \sum\limits_{k = 0}^{\min(cnt_{i},tmp)}dp_{i - 1,j - k} \times \binom{cnt_{i}}{k} \times \binom{tmp - j}{cnt_{i} - k}
$$

很明显，$f_{i} = dp_{m,i}$，其中 $m$ 表示颜色总数。然后我们就得出了答案，时间复杂度为 $\mathcal{O}(n^2)$。

code:
```cpp
sort(a + 1,a + n + 1);
int m = unique(a + 1,a + n + 1) - a - 1,tmp = 0;
dp[0][0] = 1;
for (int i = 1; i <= m; i++)
{
    tmp += cnt[a[i]];
    for (int j = 0; j <= tmp; j++)
        for (int k = 0; k <= min(j,cnt[a[i]]); k++)
            dp[i][j] = (dp[i][j] + dp[i - 1][j - k] * c(tmp - j,cnt[a[i]] - k) % mod * c(cnt[a[i]],k) % mod) % mod;
}
int ans = 0;
for (int i = 0; i <= n; i++)
    ans = ((ans + (i & 1 ? -1 : 1) * dp[m][i]) % mod + mod) % mod;
```