---
title: "日记"
description: "这是2024年12月05日的日记"
pubDate: "Dec 05 2024"
image: "/Sigewinne_3.webp"
categories:
  - life
tags:
  - 日记
---

今天也是不用考试，也是可以补题。

### 上午
补状压dp。

<a href = "https://www.luogu.com.cn/problem/P10975" target = "_blank">P10975 Mondriaan's Dream</a> <a href = "https://www.cnblogs.com/Brilliant11001/p/18386601" target = "_blank">solution</a>  
~~我不是就在写题解吗，那我还加 `solution` 链接干什么~~  
设 $dp_{i,j}$ 表示前 $i - 1$ 行都被填满了且 $i - 1$ 行突出到 $i$ 行的方案数。然后我们可以预处理每个状态 $j$ 可以由那些状态转移而来，设转移状态的集合为 $a_j$ ，那么有：
$$
dp_{i,j} = \sum\limits_{k \in a_j}dp_{i - 1,k} 
$$
初始化 $dp_{1,0} = 0$ 我们就可以得到答案为 $dp_{h + 1,2 ^ w - 1}$

<a href = "https://www.luogu.com.cn/problem/P2831" target = "_blank">P2831 [NOIP2016 提高组] 愤怒的小鸟</a> <a href = "https://www.luogu.com.cn/article/3qr2i0cr">solution</a>  
设 $dp_i$ 表示死猪状态为 $i$ 时的最少消耗。那么有朴素的转移：枚举两个点 $i,j$ ，与原点确定抛物线，然后再枚举一个点 $k$ ，看 $k$ 是否再之前所确定的那条抛物线上。时间复杂度 $O(T \times n^3 \times 2^n)$ 。总共要算 $18^3 \times 2^{18} \approx 1.5 \times 10^{10}$ 次，绝对要T。  
我们考虑怎么优化。预处理 $vis_{i,j}$ 表示原点与 $i$ 点和 $j$ 确定出来的抛物线经过的点，那么就不用枚举 $k$ 了，时间复杂度 $O(T \times n^2 \times 2^n)$ ，算了一下大概要算 $8.4 \times 10^9$ 次，还是要T。  
我们继续优化。我们发现，如果先打 $1,3$ 两头猪再打 $2,4$ 两头猪，和先打 $2,4$ ， 再打 $1,3$ 效果事一样的，那么我们就可以预处理一个数组 $low_i$ 表示最小（或最大）的 $x$ ，使得 `i & (1 << x)` 为 $0$ 。那么我们就只用枚举一个 $i$ ，时间复杂度降到了 $O(T \times n \times 2^n)$ 就可以过了。

### 下午
把昨天的T3改了。

<a href = "https://atcoder.jp/contests/arc099/tasks/arc099_c" target = "_blank">[ARC099E] Independence</a>（就是昨天T3）  
因为个人觉得那些题解讲的都太水了，所以就不放 `solution` 链接了。  
他说要把这一个图分成两个完全子图，我们考虑取<a href = "https://oi-wiki.org/graph/concept/" target = "_blank">补图</a>。根据补图的性质，原图每条边的两个端点在补图里都不直接连通或不连通，我们就可以发现，就是要把补图<a href = "https://blog.csdn.net/wljoi/article/details/101385813">二分图染色</a>。在染色过程中我们就可以判断是否无解。而我们又想求最少有多少条边属于一个完全子图（在原图中的），我们设一个子图的点数为 $a$ ，另一个子图的点数为 $b$ 。那么我们的答案就是 $ans = \frac{a (a - 1) + b(b - 1)}{2}$ 。我们考虑dp。在染色的时候，我们记录一下，对于一个二分子图（因为取补图后不保证连通）染成颜色 $1$ 的点数为 $cnt_1$ ，染成颜色 $2$ 的是 $cnt_2$ 。用 `bitset` 记录哪几个完全子图大小能凑出来（因为 `bitset` 常数小到爆），然后枚举每一个 $i \in [0,n]$ 记录最大的 $ans$ ，这题就做完了。

今天是 `wgc` 的 $15$ 岁生日，让我们祝他生日快乐！！

### 晚上
<a href = "https://www.luogu.com.cn/problem/P3959" target = "_blank">P3959 [NOIP2017 提高组] 宝藏</a> <a href = "https://www.luogu.com.cn/article/85lzuzv9" target = "_blank">solution</a>  
这个东西，第一眼看过去以为是最小生成树，但是加一条边的边权并不直接是 $L$ ，而是 $L \times K$ ，所以最小生成树不正确。  
我们考虑dp。设 $dp_{k,i}$ 表示第 $k$ 层访问情况为 $i$ 的点的最小代价。其中，$k$ 表示从起点到 $u \in i$ 中的任意一个点所经过的宝藏屋数量，而 $i$ 表示一共访问了哪几个点，如图：
<img src = "\P3959.webp">  
这其中，当加粗的点 $1$ 作为起始点的时候，它的层数就为 $1$ 。而 $2,3,4$ 就在第二层，此时第二层的情况为 `001111` 。以此类推，$5,6$ 就在第三层，第三层情况为 `111111` 。  
那么讲完了状态设计，我们接下来就可以讲转移了。设当第 $k$ 层状态为 $i$ 时，$dp_{k,i}$ 就等于 $\sum\limits_{j \subset i}dp_{k - 1,j} + w_{u,j}$ ，其中，$w_{u,j}$ 表示 $\min\limits_{v \in j}(dis_{u,v})$ 。然后我们就可以通过枚举 $i,j,k,u$ 来求得答案。实现：
```cpp
for (int i = 1; i <= n; i++)
    for (int j = 1; j < (1 << n); j++)
        for (int k = 1; k <= n; k++)
            if (!(j & (1 << (i - 1))) && (j & (1 << (k - 1))))
                w[i][j] = min(w[i][j],dis[i][k]);
for (int i = 1; i <= n; i++)
    dp[1][(1 << (i - 1))] = 0;
for (int i = 1; i < (1 << n); i++)
{
    for (int j = i & (i - 1); j; j = i & (j - 1))
    {
        int tmp = 0;
        for (int k = 1; k <= n; k++)//这里的k就相当于上文的u
        {
            if ((1 << (k - 1)) & (i - j))
            {
                if (w[k][j] > inf)
                    tmp = inf;
                else
                    tmp += w[k][j];
            }
        }
        for (int k = 2; k <= n; k++)
            if (dp[k - 1][j] != inf && tmp != inf)
                dp[k][i] = min(dp[k][i],dp[k - 1][j] + tmp * (k - 1));
    }
}
```