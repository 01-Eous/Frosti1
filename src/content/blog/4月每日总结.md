---
title: "4月每日总结"
description: "这是4月份的每日总结"
pubDate: "Apr 1 2025"
image: "/head_pic/Klee_2.webp"
categories:
  - life
tags:
  - 日记
---

## 4 月 1 日

我尽力，我无悔。

### T1

对于那种只输入一两个数的题，首先不要去想正解，先猜半个小时结论看看猜不猜的出来。~~多半是猜的出来的~~

可是我写 T2 去了。

发现从 $0$ 有 $\frac{1}{n}$ 的概率一发入魂。而剩下 $\frac{n - 1}{n}$ 的概率就是在 $[1,n - 1]$。对于每个点都有 $\frac{1}{n}$ 的概率赢，有 $\frac{n - 2}{n}$ 的概率留在 $[1,n - 1]$，那么对于每个 $i \in [1,n - 1]$ 都是一样的。期望是 $1 + \frac{(n - 1)^2}{n}$。

### T2

赛时想法：设 $dp_{i,j}$ 表示第 $i$ 个点取值为 $j$ 的方案数。显然有：$dp_{i,j} = \sum\limits_{k = 1}^{a_i}dp_{i - 1,k} \times [k \neq j]$。复杂度 $O(nV^2)$，可以通过全局和优化到 $O(nV)$，然后拿到 $20$ 的好成绩。\
我们发现这玩意可以简化成三个操作：区间取反，区间赋值，区间加。前面两个都是特化的区间乘。我们直接动开线段树，花了 2h 的时间获得的 $60$ 的<font color = ff0000>好成绩</font>。

正解是这样的：正难则反。我们想要求**恰好**有 $0$ 个非法点的情况数，我们就尝试求**钦定**有 $i$ 个非法点的情况数 $F(i)$，然后反演一下得到最终的答案。

考虑如何求 $F(i)$。设 $dp_{i,j}$ 表示前 $i$ 个数分 $j$ 段的方案数。显然有 $F(i) = dp_{i,n - i}$。有显然的转移：$dp_{i,j} = \sum\limits_{k = 1}^{i}dp_{k - 1,j - 1} \times \min\limits_{l = k}^{i}a_l$。复杂度 $O(n^3)$，可以拿到 $0$ 分的~~好成绩~~。

我们发现我们不关心 $j$ 的值，只关心它的奇偶性。我们就可以每次转移都乘一个 $-1$，变成 $dp_i = \sum\limits_{k = 1}^{i}-dp_{k - 1} \times \min\limits_{l = k}^{i}a_l$。复杂度 $O(n^2)$，可以获得 $60$ 的好成绩。

最后用单调栈优化到 $O(n)$ 即可通过。

### T3

我们发现如果对于一个可行的方案，每个数都异或一个 $x$，最终答案也可行。且总的异或和也异或了 $y$。所以我们不用考虑具体的方案，求出总方案数除以 $2^k$ 就行。

考虑先填好第二行，方案数 $2^k \times (2^k - 1) \times (2^k - 2) \times \cdots \times (2^k - n)$，然后钦定第一行有 $i$ 个与第二行冲突，方案数为 $(2^k - i) \times (2^k - i - 1) \times (2^k - i - 2) \times \cdots \times (2^k - n + 1)$。直接反演得到恰好有 $0$ 个与之冲突的方案数。

### 后日谈

今天就是纯纯的数学题综合训练。于是开始~~预习~~复习概率与期望。

我尽力，我无悔。

## 4 月 2 日

不计代价。

~~不过我要是真的能做到 _不计代价_ 的学习的话，我就不会那么菜了。~~

### [DFS Order 2](https://www.luogu.com.cn/problem/P9669)

我们想到，一个子树内的 dfs 序肯定是连续的，我们考虑跑一个背包。设 $dp_{u,i}$ 表示 $u$ 在第 $i$ 个被访问的方案数。我们先想总共有多少个 dfs 序。那么显然，如果有 $tot_u$ 个子树，那么就有 $tot_u !$ 个子树排列的方式。每个子树又有自己的排列方式，乘起来就是了。$dp_{1,1}$ 就是总的排列方式数。初始化就完了。

考虑如何转移：我们想从 $dp_{u,i} \to dp_{v,j}$。我们发现，一次加的肯定是一整个子树。那么我们想：做背包！设 $tmp_j$ 表示 两个点在 dfs 序上相距 $j$ 的方案数。转移有显然的 $dp_{v,j} \leftarrow dp_{u,i} + tmp_{j - i}$。

但是我们发现：子树之间是不分顺序的，我们转移 $v$ 的时候还得扣掉 $v$ 的子树。我们不可能对于每个子树都做个不考虑它的背包，那么复杂度直奔 $O(n^4)$，显然不可取。

我们想：效仿淀粉质！每次扣掉 $v$ 的子树所做的贡献，转移完再加回来。我们在每个 $u$ 的子树转移时设单独的 $f_{i,j}$。表示在 $i$ 个子树内总共选了 $j$ 个点的方案数。那么初始化有 $f_{0,0} = 1$。转移有显然的 $f_{i,j} \leftarrow f_{i - 1,j - siz_v}$。

那么我们又如何从 $f \to tmp \to dp$ 呢？对于 $f \to tmp$，有 $tmp_{j + 1} = f_{i,j} \times i! \times (tot_u - i - 1)!$，三项分别表示 **$i$ 个子树内的方案数**，**$i$ 个儿子排列的方案数**，**剩下儿子排列的方案数**。

但是我们输出发现：比例正确，值错误。我们~~直接化到最简~~。我们发现比例正确但是值不正确的原因是有 $tmp_i$，~~所以就是直接化到最简~~。

Core code:

```cpp
\\ 预处理
int dfs1(int u,int fa)
{
    int res = 1;
    siz[u] = 1,tot[u] = 0;
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        res = res * dfs1(v,u) % mod;
        siz[u] += siz[v],tot[u]++;
    }
    return res * fac[tot[u]] % mod;
}

\\ 转移
void dfs2(int u,int fa)
{
    memset(f,0,sizeof f);
    f[0][0] = 1;
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        for (int i = tot[u]; i >= 1; i--)
            for (int j = siz[u]; j >= siz[v]; j--)
                f[i][j] = (f[i][j] + f[i - 1][j - siz[v]]) % mod;
    }
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        for (int i = 1; i <= tot[u]; i++)
            for (int j = siz[v]; j <= siz[u]; j++)
                f[i][j] = (f[i][j] - f[i - 1][j - siz[v]] + mod) % mod;
        memset(tmp,0,sizeof tmp);
        for (int i = 0; i < tot[u]; i++)
            for (int j = 0; j <= siz[u]; j++)
                tmp[j + 1] = (tmp[j + 1] + fac[i] * fac[tot[u] - 1 - i] % mod * f[i][j] % mod) % mod;
        for (int i = 1; i <= n; i++)
            for (int j = 1; i + j <= n; j++)
                dp[v][i + j] = (dp[v][i + j] + dp[u][i] * tmp[j]) % mod;
        for (int i = tot[u]; i >= 1; i--)
            for (int j = siz[u]; j >= siz[v]; j--)
                f[i][j] = (f[i][j] + f[i - 1][j - siz[v]]) % mod;
    }
    for (auto v : g[u])
        if (v != fa)
            dfs2(v,u);
}

\\ 输出化简
for (int i = 1; i <= n; i++)
{
    int sum = 0;
    for (int j = 1; j <= n; j++)
        sum = (sum + dp[i][j]) % mod;
    int tmp = binpow(sum,mod - 2);
    for (int j = 1; j <= n; j++)
        printf("%lld%c",dp[i][j] * dp[1][1] % mod * tmp % mod," \n"[j == n]);
}
```

### [Great Expectations](https://codeforces.com/gym/103049/problem/G)

原题也做不起吗？

我们考虑 ~~ctj~~ 设 $dp_{i,j}$ 表示在 $i$ 个困难之后花费了 $j$ 分钟的方案数。那么有转移：

$$
dp_{i,j} = p_i \times dp_{i + 1,j + tim} + tim + \\ \begin{cases}
\min\{dp_{0,0},dp_{i + 1,j + d_i + tim} + d_i + tim\} & j + d_i + n - t_i < r\\
dp_{0,0} & \text{otherwise.}
\end{cases}
$$

具体来讲，就是如果还有可能破纪录，就尝试能不能破纪录。反之直接重开。但是我们发现这玩意有后效性，~~直接高斯消元~~。高斯消元肯定是不可取的，毕竟有个 $\min$ 在那里镇着。我们考虑二分 $dp_{0,0}$。如果最终的 $dp_{0,0}$ 比 $mid$ 小，就说明有些本该重开的我们选择了继续打，往小二分。反之往大二分。

### [糖果大战](https://acm.hdu.edu.cn/showproblem.php?pid=1204)

高斯消元 yyds

### [游走](https://www.luogu.com.cn/problem/P6154)

此游走非彼游走。

设总共有 $cnt$ 条路径，总长为 $len$。那么直接 dfs 搜出每个以每个点为起点的路径数量和路程总长，一加一除就出来了。

如果这题没模我不炸了？

### [汉堡 Burger](https://www.luogu.com.cn/problem/UVA557)

题意简化：有一个 01 串，0 的数量和 1 的数量各占一半。且最后的两个是连续的 1，求出这么滴的概率。

正难则反。设 $ans_i$ 为长度为 $i$ 的不成立的概率。那么显然有 $\displaystyle ans_n = \frac{\binom{n - 2}{\frac{n}{2} - 1}}{2^{n - 2}}$。我们发现这题没模，不能预处理阶乘。考虑推式子。推得 $ans_i = ans_{i - 2} \times \frac{i - 1}{i}$。答案就是 $1 - ans_n$。

### 后日谈

我都写 Java 了我还管常数吗？

好想念小学时无忧无虑的周末啊。。。

## 4 月 6 日

沟槽的构造题。

今天早上打 VP，直接被构造题创飞，于是开始练习构造。

好像练了 dp 就只会 dp 一样。~~其实 dp 也不够会~~，其他都不会做。

### [Arcology On Permafrost](https://codeforces.com/contest/2084/problem/D)

考虑 $f(a)$ 的最大值。首先一定有 $f(a) \le n - m \times k$，因为一个序列的 $\operatorname{MEX}$ 不可能大于它的长度。还有 $f(a) \le \lfloor \frac{n}{m + 1} \rfloor$，因为为了在 $m$ 次里，每个数都有剩的，每个数的出现次数必须大于 $m + 1$。

考虑如何构造：

- 当 $n - m \times k < \lfloor \frac{n}{m + 1} \rfloor$，那么我们有 $i \in [0,n),a_i = i \bmod k$，这样可以保证无论删掉哪几个子串，最后都会有 $a_i = i$，使得 $\operatorname{MEX}$ 最大。
- 当 $n - m \times k \ge \lfloor \frac{n}{m + 1} \rfloor$，我们可以构造 $i \in [0,n),a_i = i \bmod \lfloor \frac{n}{m + 1} \rfloor$。这样可以保证相同的数字之间至少有 $k$ 的距离，每个数还有至少 $m + 1$ 个。

### [Happy Birthday! 3](https://atcoder.jp/contests/abc400/tasks/abc400_f?lang=en)

神金区间 dp。

[自己写的 solution](https://www.cnblogs.com/Eous/p/18811677)

### 后日谈

自己抓了一点构造题来练，我连黄的构造题都做不太出来我还去做蓝色的构造题，我扯吧我。

忽然发现今天好像就做了这几道题，也是十分的颓废。

## 4 月 7 日

今天也是**不颓**。

~~所以到底是颓还是不颓？~~

### [Blossom](https://codeforces.com/contest/2084/problem/E)

没搞懂。

等洛谷上有题解了再去看一遍。

### [Roller Coaster](https://atcoder.jp/contests/pakencamp-2024-day3-2/tasks/pakencamp_2024_day3_2_e?lang=en)

神 tm Adhoc。

考虑对于一个已经选好的路径，我们找到高度相差最大的两个点，显然有结论：在这俩点里转来转去肯定是比当前路径更优的。于是我们直接找到一对 $|h_u - h_v|$ 最大的 $u,v$，答案就是 $\frac{|h_u - h_v|}{2}$

只能说我太蠢了。

### [Big XOR Game](https://atcoder.jp/contests/pakencamp-2024-day3-1/tasks/pakencamp_2024_day3_1_h?lang=en)

自己想到了 $75\%$，还是挺不错的。\
下次能想到 $100\%$ 就更好了。

想到之前考试有道题。设所有的数异或和为 $sum$，当 $sum = 0$ 时肯定平局。否则一定在 $sum$ 的最高位决出胜负。问题转化为：有 $n$ 个数，里面有奇数个 $1$，先后手轮流取，取了奇数个 $1$ 的人获胜。

考虑分类讨论，设有 $cnt$ 个 $1$：

有偶数数个 $0$（$n$ 为奇数）

- 当 $cnt \equiv 1 \pmod 4$\
Alice 先取一个 $1$，之后都和 Bob 取相同的。Alice 取了奇数个 $1$，Alice 得了 MVP！！！
- 当 $cnt \equiv 3 \pmod 4$\
Bob 总和 Alice 取相同的，Bob 取了奇数个 $1$，Bob 得了 MVP！！！

有奇数个 $0$（$n$ 为偶数）

- 当 $cnt \equiv 1 \pmod 4$\
同上情况 1，必胜。
- 当 $cnt \equiv 3 \pmod 4$\
Alice 取了 $0$，变成上面的情况 2 的后手，必胜。

### [Bracket Sequence](https://atcoder.jp/contests/pakencamp-2024-day3-2/tasks/pakencamp_2024_day3_2_g?lang=en)

唐题。

我们考虑 dp。$dp_i$ 表示到 $i$ 的 h 的数量（其实就是方案数啦）。考虑转移：$dp_i = dp_{i - 1} + \sum dp_j$。其中 $j$ 满足 $(j,i]$ 是一个合法的括号序列。

考虑如何快速求这个 $\sum dp_j$。我们想到记录一个 $bel_i$ 表示将 `(` 视为 $1$，`)` 视为 $-1$ 的前缀和。维护一个 $sum_j$ 表示所有 $bel_i = j$ 的 $dp_i$ 之和。但是我们发现一个问题：这个括号序列：`()()`，第 $3$ 个会从第 $1$ 个转移而来。但是很显然，`)(` 并不是一个合法的括号序列。我们考虑如何 ban 掉这种情况。

我们发现出现这种情况当且仅当有 $k \in (j,i]$ 满足 $bel_k < bel_i$。我们考虑开一颗线段树。下标为 $i$ 的地方维护 $bel_i$ 出现的最后一个地方。对于每个 $bel$ 开一个队列。在线段树上查询 $lst$ 表示 $[1,bel_i - 1]$ 的区间最小值，把队列里在 $lst$ 之前的全扔出去，并从 $sum_{bel_i}$ 中减去。然后转移 $dp_i = dp_{i - 1} + sum_{bel_i}$。然后更新线段树，将 $i$ 压进队列并将 $sum_{bel_i}$ 加上 $dp_i$。

最后的答案就是 $dp_n$。

还是 _赛格门特吹_ 好用。

### [Colourful Bottles](https://atcoder.jp/contests/pakencamp-2024-day3-1/tasks/pakencamp_2024_day3_1_b?lang=en)

听 dpfs 讲的。

考虑 dp，设 $dp_i$ 表示以 $i$ 结尾，满足 $k$ 连续的最小代价。考虑转移：

$$
dp_i = \min\begin{cases}
dp_{i - 1} + w_i & \text{直接删掉 } i \\
dp_{j - 1} + sumw_i - sumw_{j - 1} + sumc_i - sumc_j + w_j & \text{不删 } i
\end{cases}
$$

其中 $sumw_i$ 表示 $w$ 的前缀和。$sumc_i$ 表示与 $i$ 颜色相同的前缀和。第二个方程具体来说就是：删掉 $[j,i]$ 之间的所有数，但是同色的不能删，于是把它加回来。而我们不知道 $j$ 的相同颜色的前驱是啥，于是直接减掉 $sumc_j - w_j$。$j$ 要满足 $[j,i]$ 之间至少有 $k$ 个同颜色的。

考虑优化。对于每个颜色开一个 $min$ 数组表示 $dp_j - sumw_{j - 1} - sumc_j + w_j$ 的最小值。又对于每个颜色开一个队列。当队列长度等于 $k - 1$ 时，就把对头取出，更新 $min$ 数组。然后转移 $dp_i = \min\{dp_{i - 1} + w_i,min_{c_i} + sumw_i + sumc_i\}$。转移完了扔进队列。

### 后日谈

明天的模拟赛和重庆八中联考。~~又可以丢 CW 的脸了~~。

每次一看到这个高达 $\color{#ff0000}16.7\%$ 的得分率我就头大。明明打的对的题，总是因为一些莫名其妙的愿因挂分。要么是实现太优秀，常数爆炸，要么是没注意细节。

There's no time left.