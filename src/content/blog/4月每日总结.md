---
title: "4月每日总结"
description: "这是4月份的每日总结"
pubDate: "Apr 1 2025"
image: "/head_pic/Klee_2.webp"
categories:
  - life
tags:
  - 日记
---

## 4 月 1 日

我尽力，我无悔。

### T1

对于那种只输入一两个数的题，首先不要去想正解，先猜半个小时结论看看猜不猜的出来。~~多半是猜的出来的~~

可是我写 T2 去了。

发现从 $0$ 有 $\frac{1}{n}$ 的概率一发入魂。而剩下 $\frac{n - 1}{n}$ 的概率就是在 $[1,n - 1]$。对于每个点都有 $\frac{1}{n}$ 的概率赢，有 $\frac{n - 2}{n}$ 的概率留在 $[1,n - 1]$，那么对于每个 $i \in [1,n - 1]$ 都是一样的。期望是 $1 + \frac{(n - 1)^2}{n}$。

### T2

赛时想法：设 $dp_{i,j}$ 表示第 $i$ 个点取值为 $j$ 的方案数。显然有：$dp_{i,j} = \sum\limits_{k = 1}^{a_i}dp_{i - 1,k} \times [k \neq j]$。复杂度 $O(nV^2)$，可以通过全局和优化到 $O(nV)$，然后拿到 $20$ 的好成绩。\
我们发现这玩意可以简化成三个操作：区间取反，区间赋值，区间加。前面两个都是特化的区间乘。我们直接动开线段树，花了 2h 的时间获得的 $60$ 的<font color = ff0000>好成绩</font>。

正解是这样的：正难则反。我们想要求**恰好**有 $0$ 个非法点的情况数，我们就尝试求**钦定**有 $i$ 个非法点的情况数 $F(i)$，然后反演一下得到最终的答案。

考虑如何求 $F(i)$。设 $dp_{i,j}$ 表示前 $i$ 个数分 $j$ 段的方案数。显然有 $F(i) = dp_{i,n - i}$。有显然的转移：$dp_{i,j} = \sum\limits_{k = 1}^{i}dp_{k - 1,j - 1} \times \min\limits_{l = k}^{i}a_l$。复杂度 $O(n^3)$，可以拿到 $0$ 分的~~好成绩~~。

我们发现我们不关心 $j$ 的值，只关心它的奇偶性。我们就可以每次转移都乘一个 $-1$，变成 $dp_i = \sum\limits_{k = 1}^{i}-dp_{k - 1} \times \min\limits_{l = k}^{i}a_l$。复杂度 $O(n^2)$，可以获得 $60$ 的好成绩。

最后用单调栈优化到 $O(n)$ 即可通过。

### T3

我们发现如果对于一个可行的方案，每个数都异或一个 $x$，最终答案也可行。且总的异或和也异或了 $y$。所以我们不用考虑具体的方案，求出总方案数除以 $2^k$ 就行。

考虑先填好第二行，方案数 $2^k \times (2^k - 1) \times (2^k - 2) \times \cdots \times (2^k - n)$，然后钦定第一行有 $i$ 个与第二行冲突，方案数为 $(2^k - i) \times (2^k - i - 1) \times (2^k - i - 2) \times \cdots \times (2^k - n + 1)$。直接反演得到恰好有 $0$ 个与之冲突的方案数。

### 后日谈

今天就是纯纯的数学题综合训练。于是开始~~预习~~复习概率与期望。

我尽力，我无悔。

## 4 月 2 日

不计代价。

~~不过我要是真的能做到 _不计代价_ 的学习的话，我就不会那么菜了。~~

### [DFS Order 2](https://www.luogu.com.cn/problem/P9669)

我们想到，一个子树内的 dfs 序肯定是连续的，我们考虑跑一个背包。设 $dp_{u,i}$ 表示 $u$ 在第 $i$ 个被访问的方案数。我们先想总共有多少个 dfs 序。那么显然，如果有 $tot_u$ 个子树，那么就有 $tot_u !$ 个子树排列的方式。每个子树又有自己的排列方式，乘起来就是了。$dp_{1,1}$ 就是总的排列方式数。初始化就完了。

考虑如何转移：我们想从 $dp_{u,i} \to dp_{v,j}$。我们发现，一次加的肯定是一整个子树。那么我们想：做背包！设 $tmp_j$ 表示 两个点在 dfs 序上相距 $j$ 的方案数。转移有显然的 $dp_{v,j} \leftarrow dp_{u,i} + tmp_{j - i}$。

但是我们发现：子树之间是不分顺序的，我们转移 $v$ 的时候还得扣掉 $v$ 的子树。我们不可能对于每个子树都做个不考虑它的背包，那么复杂度直奔 $O(n^4)$，显然不可取。

我们想：效仿淀粉质！每次扣掉 $v$ 的子树所做的贡献，转移完再加回来。我们在每个 $u$ 的子树转移时设单独的 $f_{i,j}$。表示在 $i$ 个子树内总共选了 $j$ 个点的方案数。那么初始化有 $f_{0,0} = 1$。转移有显然的 $f_{i,j} \leftarrow f_{i - 1,j - siz_v}$。

那么我们又如何从 $f \to tmp \to dp$ 呢？对于 $f \to tmp$，有 $tmp_{j + 1} = f_{i,j} \times i! \times (tot_u - i - 1)!$，三项分别表示 **$i$ 个子树内的方案数**，**$i$ 个儿子排列的方案数**，**剩下儿子排列的方案数**。

但是我们输出发现：比例正确，值错误。我们~~直接化到最简~~。我们发现比例正确但是值不正确的原因是有 $tmp_i$，~~所以就是直接化到最简~~。

Core code:

```cpp
\\ 预处理
int dfs1(int u,int fa)
{
    int res = 1;
    siz[u] = 1,tot[u] = 0;
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        res = res * dfs1(v,u) % mod;
        siz[u] += siz[v],tot[u]++;
    }
    return res * fac[tot[u]] % mod;
}

\\ 转移
void dfs2(int u,int fa)
{
    memset(f,0,sizeof f);
    f[0][0] = 1;
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        for (int i = tot[u]; i >= 1; i--)
            for (int j = siz[u]; j >= siz[v]; j--)
                f[i][j] = (f[i][j] + f[i - 1][j - siz[v]]) % mod;
    }
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        for (int i = 1; i <= tot[u]; i++)
            for (int j = siz[v]; j <= siz[u]; j++)
                f[i][j] = (f[i][j] - f[i - 1][j - siz[v]] + mod) % mod;
        memset(tmp,0,sizeof tmp);
        for (int i = 0; i < tot[u]; i++)
            for (int j = 0; j <= siz[u]; j++)
                tmp[j + 1] = (tmp[j + 1] + fac[i] * fac[tot[u] - 1 - i] % mod * f[i][j] % mod) % mod;
        for (int i = 1; i <= n; i++)
            for (int j = 1; i + j <= n; j++)
                dp[v][i + j] = (dp[v][i + j] + dp[u][i] * tmp[j]) % mod;
        for (int i = tot[u]; i >= 1; i--)
            for (int j = siz[u]; j >= siz[v]; j--)
                f[i][j] = (f[i][j] + f[i - 1][j - siz[v]]) % mod;
    }
    for (auto v : g[u])
        if (v != fa)
            dfs2(v,u);
}

\\ 输出化简
for (int i = 1; i <= n; i++)
{
    int sum = 0;
    for (int j = 1; j <= n; j++)
        sum = (sum + dp[i][j]) % mod;
    int tmp = binpow(sum,mod - 2);
    for (int j = 1; j <= n; j++)
        printf("%lld%c",dp[i][j] * dp[1][1] % mod * tmp % mod," \n"[j == n]);
}
```

### [Great Expectations](https://codeforces.com/gym/103049/problem/G)

原题也做不起吗？

我们考虑 ~~ctj~~ 设 $dp_{i,j}$ 表示在 $i$ 个困难之后花费了 $j$ 分钟的方案数。那么有转移：

$$
dp_{i,j} = p_i \times dp_{i + 1,j + tim} + tim + \\ \begin{cases}
\min\{dp_{0,0},dp_{i + 1,j + d_i + tim} + d_i + tim\} & j + d_i + n - t_i < r\\
dp_{0,0} & \text{otherwise.}
\end{cases}
$$

具体来讲，就是如果还有可能破纪录，就尝试能不能破纪录。反之直接重开。但是我们发现这玩意有后效性，~~直接高斯消元~~。高斯消元肯定是不可取的，毕竟有个 $\min$ 在那里镇着。我们考虑二分 $dp_{0,0}$。如果最终的 $dp_{0,0}$ 比 $mid$ 小，就说明有些本该重开的我们选择了继续打，往小二分。反之往大二分。

### [糖果大战](https://acm.hdu.edu.cn/showproblem.php?pid=1204)

高斯消元 yyds

### [游走](https://www.luogu.com.cn/problem/P6154)

此游走非彼游走。

设总共有 $cnt$ 条路径，总长为 $len$。那么直接 dfs 搜出每个以每个点为起点的路径数量和路程总长，一加一除就出来了。

如果这题没模我不炸了？

### [汉堡 Burger](https://www.luogu.com.cn/problem/UVA557)

题意简化：有一个 01 串，0 的数量和 1 的数量各占一半。且最后的两个是连续的 1，求出这么滴的概率。

正难则反。设 $ans_i$ 为长度为 $i$ 的不成立的概率。那么显然有 $\displaystyle ans_n = \frac{\binom{n - 2}{\frac{n}{2} - 1}}{2^{n - 2}}$。我们发现这题没模，不能预处理阶乘。考虑推式子。推得 $ans_i = ans_{i - 2} \times \frac{i - 1}{i}$。答案就是 $1 - ans_n$。

### 后日谈

我都写 Java 了我还管常数吗？

好想念小学时无忧无虑的周末啊。。。

## 4 月 6 日

沟槽的构造题。

今天早上打 VP，直接被构造题创飞，于是开始练习构造。

好像练了 dp 就只会 dp 一样。~~其实 dp 也不够会~~，其他都不会做。

### [Arcology On Permafrost](https://codeforces.com/contest/2084/problem/D)

考虑 $f(a)$ 的最大值。首先一定有 $f(a) \le n - m \times k$，因为一个序列的 $\operatorname{MEX}$ 不可能大于它的长度。还有 $f(a) \le \lfloor \frac{n}{m + 1} \rfloor$，因为为了在 $m$ 次里，每个数都有剩的，每个数的出现次数必须大于 $m + 1$。

考虑如何构造：

- 当 $n - m \times k < \lfloor \frac{n}{m + 1} \rfloor$，那么我们有 $i \in [0,n),a_i = i \bmod k$，这样可以保证无论删掉哪几个子串，最后都会有 $a_i = i$，使得 $\operatorname{MEX}$ 最大。
- 当 $n - m \times k \ge \lfloor \frac{n}{m + 1} \rfloor$，我们可以构造 $i \in [0,n),a_i = i \bmod \lfloor \frac{n}{m + 1} \rfloor$。这样可以保证相同的数字之间至少有 $k$ 的距离，每个数还有至少 $m + 1$ 个。

### [Happy Birthday! 3](https://atcoder.jp/contests/abc400/tasks/abc400_f?lang=en)

神金区间 dp。

[自己写的 solution](https://www.cnblogs.com/Eous/p/18811677)

### 后日谈

自己抓了一点构造题来练，我连黄的构造题都做不太出来我还去做蓝色的构造题，我扯吧我。

忽然发现今天好像就做了这几道题，也是十分的颓废。

## 4 月 7 日

今天也是**不颓**。

~~所以到底是颓还是不颓？~~

### [Blossom](https://codeforces.com/contest/2084/problem/E)

没搞懂。

等洛谷上有题解了再去看一遍。

### [Roller Coaster](https://atcoder.jp/contests/pakencamp-2024-day3-2/tasks/pakencamp_2024_day3_2_e?lang=en)

神 tm Adhoc。

考虑对于一个已经选好的路径，我们找到高度相差最大的两个点，显然有结论：在这俩点里转来转去肯定是比当前路径更优的。于是我们直接找到一对 $|h_u - h_v|$ 最大的 $u,v$，答案就是 $\frac{|h_u - h_v|}{2}$

只能说我太蠢了。

### [Big XOR Game](https://atcoder.jp/contests/pakencamp-2024-day3-1/tasks/pakencamp_2024_day3_1_h?lang=en)

自己想到了 $75\%$，还是挺不错的。\
下次能想到 $100\%$ 就更好了。

想到之前考试有道题。设所有的数异或和为 $sum$，当 $sum = 0$ 时肯定平局。否则一定在 $sum$ 的最高位决出胜负。问题转化为：有 $n$ 个数，里面有奇数个 $1$，先后手轮流取，取了奇数个 $1$ 的人获胜。

考虑分类讨论，设有 $cnt$ 个 $1$：

有偶数数个 $0$（$n$ 为奇数）

- 当 $cnt \equiv 1 \pmod 4$\
Alice 先取一个 $1$，之后都和 Bob 取相同的。Alice 取了奇数个 $1$，Alice 得了 MVP！！！
- 当 $cnt \equiv 3 \pmod 4$\
Bob 总和 Alice 取相同的，Bob 取了奇数个 $1$，Bob 得了 MVP！！！

有奇数个 $0$（$n$ 为偶数）

- 当 $cnt \equiv 1 \pmod 4$\
同上情况 1，必胜。
- 当 $cnt \equiv 3 \pmod 4$\
Alice 取了 $0$，变成上面的情况 2 的后手，必胜。

### [Bracket Sequence](https://atcoder.jp/contests/pakencamp-2024-day3-2/tasks/pakencamp_2024_day3_2_g?lang=en)

唐题。

我们考虑 dp。$dp_i$ 表示到 $i$ 的 h 的数量（其实就是方案数啦）。考虑转移：$dp_i = dp_{i - 1} + \sum dp_j$。其中 $j$ 满足 $(j,i]$ 是一个合法的括号序列。

考虑如何快速求这个 $\sum dp_j$。我们想到记录一个 $bel_i$ 表示将 `(` 视为 $1$，`)` 视为 $-1$ 的前缀和。维护一个 $sum_j$ 表示所有 $bel_i = j$ 的 $dp_i$ 之和。但是我们发现一个问题：这个括号序列：`()()`，第 $3$ 个会从第 $1$ 个转移而来。但是很显然，`)(` 并不是一个合法的括号序列。我们考虑如何 ban 掉这种情况。

我们发现出现这种情况当且仅当有 $k \in (j,i]$ 满足 $bel_k < bel_i$。我们考虑开一颗线段树。下标为 $i$ 的地方维护 $bel_i$ 出现的最后一个地方。对于每个 $bel$ 开一个队列。在线段树上查询 $lst$ 表示 $[1,bel_i - 1]$ 的区间最小值，把队列里在 $lst$ 之前的全扔出去，并从 $sum_{bel_i}$ 中减去。然后转移 $dp_i = dp_{i - 1} + sum_{bel_i}$。然后更新线段树，将 $i$ 压进队列并将 $sum_{bel_i}$ 加上 $dp_i$。

最后的答案就是 $dp_n$。

还是 _赛格门特吹_ 好用。

### [Colourful Bottles](https://atcoder.jp/contests/pakencamp-2024-day3-1/tasks/pakencamp_2024_day3_1_b?lang=en)

听 dpfs 讲的。

考虑 dp，设 $dp_i$ 表示以 $i$ 结尾，满足 $k$ 连续的最小代价。考虑转移：

$$
dp_i = \min\begin{cases}
dp_{i - 1} + w_i & \text{直接删掉 } i \\
dp_{j - 1} + sumw_i - sumw_{j - 1} + sumc_i - sumc_j + w_j & \text{不删 } i
\end{cases}
$$

其中 $sumw_i$ 表示 $w$ 的前缀和。$sumc_i$ 表示与 $i$ 颜色相同的前缀和。第二个方程具体来说就是：删掉 $[j,i]$ 之间的所有数，但是同色的不能删，于是把它加回来。而我们不知道 $j$ 的相同颜色的前驱是啥，于是直接减掉 $sumc_j - w_j$。$j$ 要满足 $[j,i]$ 之间至少有 $k$ 个同颜色的。

考虑优化。对于每个颜色开一个 $min$ 数组表示 $dp_j - sumw_{j - 1} - sumc_j + w_j$ 的最小值。又对于每个颜色开一个队列。当队列长度等于 $k - 1$ 时，就把对头取出，更新 $min$ 数组。然后转移 $dp_i = \min\{dp_{i - 1} + w_i,min_{c_i} + sumw_i + sumc_i\}$。转移完了扔进队列。

### 后日谈

明天的模拟赛和重庆八中联考。~~又可以丢 CW 的脸了~~。

每次一看到这个高达 $\color{#ff0000}16.7\%$ 的得分率我就头大。明明打的对的题，总是因为一些莫名其妙的愿因挂分。要么是实现太优秀，常数爆炸，要么是没注意细节。

There's no time left.

## 4 月 8 日

今天是真的不颓。

### T1

如果说有这样的 $a = \{1,2\}$ 和 $b = \{100,101\}$，显然我们不能先加 $a_1$，而应该先加 $a_2$。而后又看到 $x$ 可以为负，想到如果说将 $a_i$ 加上 $x$ 使得 $a_i = b_i$ 且 $a_i > a_{i + 1}$，我们就连一条 $i + 1 \to i$ 的边。可以证明这是一个有向无环图。因此我们一定有用 $\sum\limits_{i = 1}^{n}[a_i \ne b_i]$ 次的方法使得 $a = b$。

现在我们考虑使代价更小。考虑对于一个 $(a_i - b_i)^2$，要使它变小，我们考率分多次。显然等分最优。赛时想到了做背包 dp，复杂度 $O(nm^2)$。可以拿到 $\color{#5ec05e}{50}$ 的好成绩。~~看这个绿色就知道确实很好~~。

正解是整一个大根堆。将每个 $(a_i - b_i)^2$ 多分一个的负贡献插入，比如初始就放每个 $(a_i - b_i)^2$ 从 $1$ 次到 $2$ 次的负贡献。取 $m - \sum\limits_{i = 1}^{n}[a_i \ne b_i]$ 次就好。

没放代码是因为下次再做的时候希望能自己写出来。

### T2

听 HD0X 讲的。

看到冒泡排序，想到逆序对。离线，从大到小枚举 $i$，并枚举每个 $x = i$ 的查询，计 $u$ 表示 $i$ 位置前面的比它大的数量，$v$ 表示 $i$ 位置后面的比它大的数量。让我们分类讨论一下（下文的 $k$ 都指查询的 $k$，$id$ 指查询编号，$pos_i$ 指 $i$ 的原位置）：

- $k \le u$\
这样的话，$i$ 前面的会在 $k$ 次冒泡后跑到 $i$ 后面去并把 $i$ 往前挤，$ans_{id} = pos_i - k$。
- $k \le u + v$\
从头开始考虑 $k$ 次冒泡。每次冒泡，一定会有一个比 $i$ 更大的数 $P_j$ 被一个更大的数 $P_{j + 1}$ 堵住，且位置比 $P_{j + 1}$ 左一个。\
我们掏个样例出来：$\{4,3,5,1,2\}$。我们想要查询 $3$ 在第 $2$ 次冒泡后的位置。\
第 $1$ 次冒泡：$\{3,4,1,2,5\}$，$4$ 被 $5$ 堵住，位置 $-1$。\
第 $2$ 次冒泡：$\{3,1,2,4,5\}$，$3$ 被 $4$ 堵住，位置 $-1$。\
这样我们看到 $3$ 在 $1$ 的位置。这个 $1$ 是由 $5$ 最初的位置经过 $2$ 次 $-1$ 后得到的。\
我们再掏一个样例：$\{3,4,2,5,1\}$。我们想要查询 $2$ 在第 $3$ 次冒泡后的位置。\
第 $1$ 次冒泡：$\{3,2,4,1,5\}$，$4$ 被 $5$ 堵住，位置 $-1$。\
第 $2$ 次冒泡：$\{2,3,1,4,5\}$，$3$ 被 $4$ 堵住，位置 $-1$。\
第 $3$ 次冒泡：$\{2,1,3,4,5\}$，$2$ 被 $3$ 堵住，位置 $-1$。\
$2$ 在 $1$ 的位置。这个 $1$ 是由 $5$ 最初的位置经过 $3$ 次 $-1$ 得到的。\
我们发现，因为在这 $k$ 次里会被堵 $k$ 次，所以最初的位置（就是上文的 $5$ 的最初的位置）一定是比 $i$ 大的数按照原序列的顺序的第 $k$ 个。而每次被堵会使得下标 $-1$，所以答案就是比 $i$ 大的数的第 $k$ 个的位置减 $k$。
- $k > u + v$\
显然这个时候 $i$ 归位了，$ans_{id} = n - u - v$。

实现可以这样：因为我们从大到小枚举 $i$，用线段树维护。每次算完 $i$ 都将线段树 $pos_i$ 的地方置为 $1$。$u$ 就是 $[1,pos_i]$ 的区间和，$v$ 就是 $[pos_i,n]$ 的区间和。“比 $i$ 大的数按照原序列的顺序的第 $k$ 个”可以通过线段树上二分找到第 $k$ 个 $i$。因为只有 $k > u$ 时才会询问第 $k$ 个，所以第 $k$ 个一定在 $i$ 原位置的右边。

### T3 & T4

补题速度还是太快了一点，没看。

### 后日谈

之前的考试挂分 $\color{#ff0000}{50}$ 起步，今天只挂了 $\color{#5ec05e}{10}$ 分，可喜可贺。

要是 T1 没有被背包误导的话就更好了。~~好歹有 50 分嘛~~

今天晚上有 div.3，打不打呢？

## 4 月 9 日

弄懂每一题。~~然而我太蠢了~~

### [Square Subsequences](https://codeforces.com/gym/103652/problem/F)

谁能给我讲讲 `bitset` 优化 LCS 啊？

简而言之就是枚举中间的分界点，然后对于两边的子串跑 `bitset` 优化 LCS。记录最大的 LCS 长度与其对应的 `bitset`。然后通过 `bitset` 反推 dp 数组，从而反推方案。时间复杂度 $O(\frac{n^3}{\omega} + n^2)$，时限 $2$ s，在 CF 神机上跑了 $1.5$ s，换别的 OJ 还不一定跑的完。

然而我太蠢了没弄懂 `bitset` 优化 LCS。

### [Adjacent Delete](https://atcoder.jp/contests/arc196/tasks/arc196_a?lang=en)

自从学了 C# 和 Java 以来，代码风格愈发面向对象了。与之而来的还有更大的常数。希望不要搞出在赛场上因为常数太大而 TLE 的事。

考虑没有相邻的限制如何做。显然是最大的 $\frac{n}{2}$ 个减去最小的 $\frac{n}{2}$ 个。现在考虑相邻的限制，这个上界也是可行的。我们把每个最大的 $\frac{n}{2}$ 的标成 `+`，最小的那几个标成 `-`。显然无论如何都会有一对 `+` 和 `-` 相邻。

对于偶数 $n$ 显然就是那个上界。对于奇数 $n$，因为会留下一个，留下的这个会将 $a$ 数组分成两半，而两边都会取完，所以两边的长度肯定都是偶数。所以留下的只能是 $a_1,a_3,a_5,\dots$，对于两边，就是上文的上界。我们可以用两个 `multiset` 维护。一个小根的维护大的那几个数，大根的维护小的那那几个数。每次如果插入的 $x$ 大于等于小根堆的堆顶，就插入小根堆。否则插入大根堆。并维护一个堆内和。

放下我的常数超大代码：

```cpp
#include<bits/extc++.h>
#define int long long
using namespace std;
const int maxn = 3e5 + 5;
int n;
int a[maxn];
class two_set
{
    private:
    multiset<int,less<>> mx;// 小根堆维护最大的几个数
    multiset<int,greater<>> mi;// 大根堆维护最小的几个数。
    void balance()
    {
        if (mx.size() > mi.size() + 1)
        {
            _min += *mx.begin();
            _max -= *mx.begin();
            mi.insert(*mx.begin());
            mx.erase(mx.begin());
        }
        if (mi.size() > mx.size())
        {
            _max += *mi.begin();
            _min -= *mi.begin();
            mx.insert(*mi.begin());
            mi.erase(mi.begin());
        }
    }
    public:
    int _min,_max;// 分别表示最小的数的和，最大的数的和。
    void insert(int x)
    {
        if (mx.empty() || x >= *mx.begin())
        {
            _max += x;
            mx.insert(x);
        }
        else
        {
            _min += x;
            mi.insert(x);
        }
        balance();
    }
    void erase(int x)
    {
        auto it = mx.find(x);
        if (it != mx.end())
        {
            _max -= x;
            mx.erase(it);
        }
        else
        {
            _min -= x;
            it = mi.find(x);
            assert(it != mi.end());
            mi.erase(it);
        }
        balance();
    }
}s1,s2;
void solve1()// 起码这里挺简洁的
{
    for (int i = 1; i <= n; i++)
        s2.insert(a[i]);
    int ans = 0;
    for (int i = 1; i <= n; i++)
    {
        s2.erase(a[i]);
        if (i & 1)
            ans = max(ans,s1._max - s1._min + s2._max - s2._min);
        s1.insert(a[i]);
    }
    printf("%lld",ans);
}
void solve2()
{
    sort(a + 1,a + n + 1);
    int _max = 0,_min = 0;
    for (int i = 1; i <= n >> 1; i++)
        _min += a[i];
    for (int i = (n >> 1) + 1; i <= n; i++)
        _max += a[i];
    printf("%lld",_max - _min);
}
signed main()
{
    scanf("%lld",&n);
    for (int i = 1; i <= n; i++)
        scanf("%lld",a + i);
    if (n & 1)
        solve1();
    else
        solve2();
    return 0;
}
```

### 后日谈

yzp 因为鞋子没垫鞋垫导致他极其不舒服。然后今天也是十分颓废，只做了 $3$ 题。

yzp 说他想回家，我的评价是：住校生是这样的。

不过住校生不开心还可以逃回家，走读生逃回家也没用，因为天天回家，对家已经无感了。不开心的时候只能畅想去到异世界。~~中二病~~