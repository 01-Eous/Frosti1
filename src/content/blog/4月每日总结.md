---
title: "4月每日总结"
description: "这是4月份的每日总结"
pubDate: "Apr 1 2025"
image: "/head_pic/Klee_2.webp"
categories:
  - life
tags:
  - 日记
---

## 4 月 1 日

我尽力，我无悔。

### T1

对于那种只输入一两个数的题，首先不要去想正解，先猜半个小时结论看看猜不猜的出来。~~多半是猜的出来的~~

可是我写 T2 去了。

发现从 $0$ 有 $\frac{1}{n}$ 的概率一发入魂。而剩下 $\frac{n - 1}{n}$ 的概率就是在 $[1,n - 1]$。对于每个点都有 $\frac{1}{n}$ 的概率赢，有 $\frac{n - 2}{n}$ 的概率留在 $[1,n - 1]$，那么对于每个 $i \in [1,n - 1]$ 都是一样的。期望是 $1 + \frac{(n - 1)^2}{n}$。

### T2

赛时想法：设 $dp_{i,j}$ 表示第 $i$ 个点取值为 $j$ 的方案数。显然有：$dp_{i,j} = \sum\limits_{k = 1}^{a_i}dp_{i - 1,k} \times [k \neq j]$。复杂度 $O(nV^2)$，可以通过全局和优化到 $O(nV)$，然后拿到 $20$ 的好成绩。\
我们发现这玩意可以简化成三个操作：区间取反，区间赋值，区间加。前面两个都是特化的区间乘。我们直接动开线段树，花了 2h 的时间获得的 $60$ 的<font color = ff0000>好成绩</font>。

正解是这样的：正难则反。我们想要求**恰好**有 $0$ 个非法点的情况数，我们就尝试求**钦定**有 $i$ 个非法点的情况数 $F(i)$，然后反演一下得到最终的答案。

考虑如何求 $F(i)$。设 $dp_{i,j}$ 表示前 $i$ 个数分 $j$ 段的方案数。显然有 $F(i) = dp_{i,n - i}$。有显然的转移：$dp_{i,j} = \sum\limits_{k = 1}^{i}dp_{k - 1,j - 1} \times \min\limits_{l = k}^{i}a_l$。复杂度 $O(n^3)$，可以拿到 $0$ 分的~~好成绩~~。

我们发现我们不关心 $j$ 的值，只关心它的奇偶性。我们就可以每次转移都乘一个 $-1$，变成 $dp_i = \sum\limits_{k = 1}^{i}-dp_{k - 1} \times \min\limits_{l = k}^{i}a_l$。复杂度 $O(n^2)$，可以获得 $60$ 的好成绩。

最后用单调栈优化到 $O(n)$ 即可通过。

### T3

我们发现如果对于一个可行的方案，每个数都异或一个 $x$，最终答案也可行。且总的异或和也异或了 $y$。所以我们不用考虑具体的方案，求出总方案数除以 $2^k$ 就行。

考虑先填好第二行，方案数 $2^k \times (2^k - 1) \times (2^k - 2) \times \cdots \times (2^k - n)$，然后钦定第一行有 $i$ 个与第二行冲突，方案数为 $(2^k - i) \times (2^k - i - 1) \times (2^k - i - 2) \times \cdots \times (2^k - n + 1)$。直接反演得到恰好有 $0$ 个与之冲突的方案数。

### 后日谈

今天就是纯纯的数学题综合训练。于是开始~~预习~~复习概率与期望。

我尽力，我无悔。

## 4 月 2 日

不计代价。

~~不过我要是真的能做到 _不计代价_ 的学习的话，我就不会那么菜了。~~

### [DFS Order 2](https://www.luogu.com.cn/problem/P9669)

我们想到，一个子树内的 dfs 序肯定是连续的，我们考虑跑一个背包。设 $dp_{u,i}$ 表示 $u$ 在第 $i$ 个被访问的方案数。我们先想总共有多少个 dfs 序。那么显然，如果有 $tot_u$ 个子树，那么就有 $tot_u !$ 个子树排列的方式。每个子树又有自己的排列方式，乘起来就是了。$dp_{1,1}$ 就是总的排列方式数。初始化就完了。

考虑如何转移：我们想从 $dp_{u,i} \to dp_{v,j}$。我们发现，一次加的肯定是一整个子树。那么我们想：做背包！设 $tmp_j$ 表示 两个点在 dfs 序上相距 $j$ 的方案数。转移有显然的 $dp_{v,j} \leftarrow dp_{u,i} + tmp_{j - i}$。

但是我们发现：子树之间是不分顺序的，我们转移 $v$ 的时候还得扣掉 $v$ 的子树。我们不可能对于每个子树都做个不考虑它的背包，那么复杂度直奔 $O(n^4)$，显然不可取。

我们想：效仿淀粉质！每次扣掉 $v$ 的子树所做的贡献，转移完再加回来。我们在每个 $u$ 的子树转移时设单独的 $f_{i,j}$。表示在 $i$ 个子树内总共选了 $j$ 个点的方案数。那么初始化有 $f_{0,0} = 1$。转移有显然的 $f_{i,j} \leftarrow f_{i - 1,j - siz_v}$。

那么我们又如何从 $f \to tmp \to dp$ 呢？对于 $f \to tmp$，有 $tmp_{j + 1} = f_{i,j} \times i! \times (tot_u - i - 1)!$，三项分别表示 **$i$ 个子树内的方案数**，**$i$ 个儿子排列的方案数**，**剩下儿子排列的方案数**。

但是我们输出发现：比例正确，值错误。我们~~直接化到最简~~。我们发现比例正确但是值不正确的原因是有 $tmp_i$，~~所以就是直接化到最简~~。

Core code:

```cpp
\\ 预处理
int dfs1(int u,int fa)
{
    int res = 1;
    siz[u] = 1,tot[u] = 0;
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        res = res * dfs1(v,u) % mod;
        siz[u] += siz[v],tot[u]++;
    }
    return res * fac[tot[u]] % mod;
}

\\ 转移
void dfs2(int u,int fa)
{
    memset(f,0,sizeof f);
    f[0][0] = 1;
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        for (int i = tot[u]; i >= 1; i--)
            for (int j = siz[u]; j >= siz[v]; j--)
                f[i][j] = (f[i][j] + f[i - 1][j - siz[v]]) % mod;
    }
    for (auto &v : g[u])
    {
        if (v == fa)
            continue;
        for (int i = 1; i <= tot[u]; i++)
            for (int j = siz[v]; j <= siz[u]; j++)
                f[i][j] = (f[i][j] - f[i - 1][j - siz[v]] + mod) % mod;
        memset(tmp,0,sizeof tmp);
        for (int i = 0; i < tot[u]; i++)
            for (int j = 0; j <= siz[u]; j++)
                tmp[j + 1] = (tmp[j + 1] + fac[i] * fac[tot[u] - 1 - i] % mod * f[i][j] % mod) % mod;
        for (int i = 1; i <= n; i++)
            for (int j = 1; i + j <= n; j++)
                dp[v][i + j] = (dp[v][i + j] + dp[u][i] * tmp[j]) % mod;
        for (int i = tot[u]; i >= 1; i--)
            for (int j = siz[u]; j >= siz[v]; j--)
                f[i][j] = (f[i][j] + f[i - 1][j - siz[v]]) % mod;
    }
    for (auto v : g[u])
        if (v != fa)
            dfs2(v,u);
}

\\ 输出化简
for (int i = 1; i <= n; i++)
{
    int sum = 0;
    for (int j = 1; j <= n; j++)
        sum = (sum + dp[i][j]) % mod;
    int tmp = binpow(sum,mod - 2);
    for (int j = 1; j <= n; j++)
        printf("%lld%c",dp[i][j] * dp[1][1] % mod * tmp % mod," \n"[j == n]);
}
```

### [Great Expectations](https://codeforces.com/gym/103049/problem/G)

原题也做不起吗？

我们考虑 ~~ctj~~ 设 $dp_{i,j}$ 表示在 $i$ 个困难之后花费了 $j$ 分钟的方案数。那么有转移：

$$
dp_{i,j} = p_i \times dp_{i + 1,j + tim} + tim + \\ \begin{cases}
\min\{dp_{0,0},dp_{i + 1,j + d_i + tim} + d_i + tim\} & j + d_i + n - t_i < r\\
dp_{0,0} & \text{otherwise.}
\end{cases}
$$

具体来讲，就是如果还有可能破纪录，就尝试能不能破纪录。反之直接重开。但是我们发现这玩意有后效性，~~直接高斯消元~~。高斯消元肯定是不可取的，毕竟有个 $\min$ 在那里镇着。我们考虑二分 $dp_{0,0}$。如果最终的 $dp_{0,0}$ 比 $mid$ 小，就说明有些本该重开的我们选择了继续打，往小二分。反之往大二分。

### [糖果大战](https://acm.hdu.edu.cn/showproblem.php?pid=1204)

高斯消元 yyds

### [游走](https://www.luogu.com.cn/problem/P6154)

此游走非彼游走。

设总共有 $cnt$ 条路径，总长为 $len$。那么直接 dfs 搜出每个以每个点为起点的路径数量和路程总长，一加一除就出来了。

如果这题没模我不炸了？

### [汉堡 Burger](https://www.luogu.com.cn/problem/UVA557)

题意简化：有一个 01 串，0 的数量和 1 的数量各占一半。且最后的两个是连续的 1，求出这么滴的概率。

正难则反。设 $ans_i$ 为长度为 $i$ 的不成立的概率。那么显然有 $\displaystyle ans_n = \frac{\binom{n - 2}{\frac{n}{2} - 1}}{2^{n - 2}}$。我们发现这题没模，不能预处理阶乘。考虑推式子。推得 $ans_i = ans_{i - 2} \times \frac{i - 1}{i}$。答案就是 $1 - ans_n$。

### 后日谈

我都写 Java 了我还管常数吗？

好想念小学时无忧无虑的周末啊。。。

## 4 月 6 日

沟槽的构造题。

今天早上打 VP，直接被构造题创飞，于是开始练习构造。

好像练了 dp 就只会 dp 一样。~~其实 dp 也不够会~~，其他都不会做。

### [Arcology On Permafrost](https://codeforces.com/contest/2084/problem/D)

考虑 $f(a)$ 的最大值。首先一定有 $f(a) \le n - m \times k$，因为一个序列的 $\operatorname{MEX}$ 不可能大于它的长度。还有 $f(a) \le \lfloor \frac{n}{m + 1} \rfloor$，因为为了在 $m$ 次里，每个数都有剩的，每个数的出现次数必须大于 $m + 1$。

考虑如何构造：

- 当 $n - m \times k < \lfloor \frac{n}{m + 1} \rfloor$，那么我们有 $i \in [0,n),a_i = i \bmod k$，这样可以保证无论删掉哪几个子串，最后都会有 $a_i = i$，使得 $\operatorname{MEX}$ 最大。
- 当 $n - m \times k \ge \lfloor \frac{n}{m + 1} \rfloor$，我们可以构造 $i \in [0,n),a_i = i \bmod \lfloor \frac{n}{m + 1} \rfloor$。这样可以保证相同的数字之间至少有 $k$ 的距离，每个数还有至少 $m + 1$ 个。

### [Happy Birthday! 3](https://atcoder.jp/contests/abc400/tasks/abc400_f?lang=en)

神金区间 dp。

[自己写的 solution](https://www.cnblogs.com/Eous/p/18811677)

### 后日谈