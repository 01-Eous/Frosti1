---
title: "日记"
description: "这是2025年1月5日的日记"
pubDate: "Dec 30 2024"
image: "/head_pic/Sigewinne_4.webp"
categories:
  - life
tags:
  - 日记
---

我终于按时更辣！

## 上午

练 **SOS**dp。

### [[ARC100E] Or Plus Max](https://atcoder.jp/contests/arc100/tasks/arc100_c)

设 $sum_{k} = \max\limits_{i,j \subseteq k}a_{i} + a_{k}$，其中 $i,j \subseteq k$ 表示 $i,j$ 在二进制下的每位都小于 $k$，类似状压 dp 里的子集。枚举子集是 $\mathcal{O}(3^{n})$ 的，不可能这么简单，所以要用 SOSdp（或者是高维前缀和）优化到 $\mathcal{O}(n \times 2^{n})$。用 dp 维护子集里的最大值和次大值，最后在每一个子集里找最大**最大 $+$ 次大**就是答案。

code:

```cpp
#include<bits/extc++.h>
#define int long long
#define inf 0x3f3f3f3f3f3f3f3f
using namespace std;
const int maxn = 1 << 18 | 5;
int n;
struct Nahida
{
    int a,b;
    Nahida():a(0),b(0){};
    friend Nahida operator+(const Nahida &x,const Nahida &y)//维护最大值和次大值
    {
        Nahida ret;
        if (x.a > y.a)
        {
            ret.a = x.a;
            ret.b = max(x.b,y.a);
        }
        else
        {
            ret.a = y.a;
            ret.b = max(x.a,y.b);
        }
        return ret;
    }
}a[maxn];
signed main()
{
    scanf("%lld",&n);
    for (int i = 0; i < (1 << n); i++)
    {
        scanf("%lld",&a[i].a);
        a[i].b = -inf;
    }
    for (int i = 0; i < n; i++)
        for (int k = 0; k < (1 << n); k++)
            if (k & (1 << i))//SOSdp（高维前缀和）
                a[k] = a[k] + a[k ^ (1 << i)];
    int ans = 0;
    for (int i = 1; i < (1 << n); i++)
    {
        ans = max(ans,a[i].a + a[i].b);//统计答案
        printf("%lld\n",ans);
    }
    return 0;
}
```