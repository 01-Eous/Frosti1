---
title: "5月每日总结"
description: "这是5月份的每日总结"
pubDate: "May 3 2025"
image: "/head_pic/Nahida_2.webp"
categories:
  - life
tags:
  - 日记
---

转眼就五月了啊，时间不多了。

## 5 月 3 日

值得记录的也就两题。

### [Neo's Escape](https://codeforces.com/contest/2108/problem/C)

我们发现，一个克隆体一次会按掉一个区间内的所有按钮。那么就直接 dp。设 $dp_i$ 为把 $[1,i]$ 这个区间内的所有按钮的都按完的最小克隆体数量。

转移十分的好写：$dp_{i} = \min\{dp_{j - 1} + 1\}$，但是 $[j,i]$ 一定要是一个克隆体能够全按完的。可以证明 $[j,i]$ 能被一次性按完，当且仅当 $[j,i]$ 形如：$a_j \le a_{j + 1} \le a_{j + 2} \le \dots \le a_{k - 1} \le a_k \ge a_{k + 1} \ge \dots \ge a_{i - 2} \ge a_{i - 1} \ge a_i$。

这么看，似乎连 $O(n^2)$ 暴力都不好写的，但是我们拥有 DS 之力，我们可以维护 $lft_i$ 满足 $[lft_i,i]$ 这段区间单调不降，再维护一个 $rht_i$ 满足 $[i,rht_i]$ 这段区间单调不增。感性理解：$dp$ 一定是单调不降的，于是我们的 $j$ 肯定最小越好。我们发现对于每个 $i$，$[lft_i,rht_i]$ 的每个子区间肯定都是合法的，那么 $[lft_i,rht_i]$ 转移的最优决策点肯定都不会在 $lft_i$ 右边。我们直接用线段树维护区间取 $\min$，单点查询。

### [Censoring G](https://www.luogu.com.cn/problem/P3121)

~~既然出现在了 AC 自动机的题单里，我们肯定就要用 AC 自动机嘛。~~

对于文本串的匹配，我们用一个栈记录一路走来的 $rt$，和 $ans$ 记录答案。如果匹配到的这个点，是一个模式串 $s$ 的结尾，栈和 $ans$ 都 `pop` $|s| $ 次。然后 $rt$ 变成新的栈顶，继续匹配。

### 后日谈

正式因为配不上她，所以我才在努力变强啊。

~~有奖竞猜：“她”代指谁？~~

## 5 月 4 日

**时间不多了。**

### T1

明天再问问。

**一定记得哦！**

### T2

AC 自动机 dp。

我们设 $dp_i$ 表示匹配前 $i$ 个字符的方案数。我们在 AC 自动机上走到的 $rt$，我们暴力跳 $fail$，如果跳到哪个节点是一个模式串的结尾，那么就说明该转移了。设这个模式串的长度为 $len$，那么显然的转移是 $dp_i$ 加上 $dp_{i - len}$。

考虑如何优化。因为只有模式串的结尾的那几个节点对转移有用。我们对于每个节点记录一个 $lst$ 表示跳 $fail$ 能跳到的第一个节点使得它是某个模式串的结尾。每次直接跳 $lst$ 就行。时间复杂度 $O(n\sqrt{n})$。

### T3

原题。但是需要一些奇技淫巧。

分两种情况考虑。

如果有集合的交集是 $\varnothing$，那么肯定只有一个。因为如果有多个，那么肯定可以合并。那么我们把所有的线段按照长度从大到小排序，取前 $k - 1$ 的就行。\
那有人要问了：如果剩下的有交集怎么办？没事，dp 会出手。

剩下的是没有交集为 $\varnothing$ 的情况。\
我们把所有的线段按照左端点排序。但是我们发现，排序完了依然不好做。究其原因是有线段包含了别的线段。我们考虑这些“包含了别的线段的线段”。如果它和它所包含的线段出现在了一个集合内，那么肯定不会影响到这个集合的答案。反之它肯定是单独成一个集合。因为如果它和别的线段一起，只可能使答案减少。

我们把“包含了别的线段的线段”的踢出去，那么剩下的肯定是左右端点都单调递增的线段。由于这样我们取一个集合只会取一个区间，于是我们 dp：设 $dp_{i,j}$ 为前 $i$ 个集合用了 $j$ 条线段。转移就是枚举 $[k,j]$ 当作最后的一个集合，然后转移。前缀和优化。

但是我们发现这玩意是 $O(nk)$ 的，无法通过。考虑 ~~奇技淫巧~~。如果 $nk > 5 \times 10^7$，也就是 $O(nk)$ 跑不过，我们就不跑 dp，跑完上面的贪心就输出。~~能过就对了~~。

### T4

没改。

### [文本生成器](https://www.luogu.com.cn/problem/P4052)

正难则反。

考虑如何求不可读的方案数。建出 AC 自动机，然后对于每个节点记录一个 $fl$ 表示它或者**它在 $fail$ 树上的祖先是否有某个是一个模式串的结尾**。然后 $dp_{i,rt}$ 表示当前已经有了 $i$ 个字符，在 $rt$ 节点上。枚举 $rt$ 在字典树上的每个儿子 $v$，如果 $v$ 的 $fl$ 不为 $1$，那么就可以转移，否则不行。答案就是 $26^m - \sum\limits_{i = 0}^{cnt}dp_{m,i}$。

### [Video Game G](https://www.luogu.com.cn/problem/P3041)

我连最基础的 dp 都做不出来了？***完蛋了***

设 $dp_{i,rt}$ 表示已经匹配了 $i$ 个字符，当前在 $rt$ 节点上。对于每个节点记录一个 $sum$ 表示这个节点是几个模式串的结尾。如果我想转移到 $v$，那么我们就得从 $v$ 往上跳 $fail$，记录从 $v \to 0$ 路径上的所有点的 $sum$ 之和为 $tmp$，转移就是 $dp_{i + 1,v}$ 对众多 $dp_{i,rt} + tmp$ 取 $\max$。可以优化。

### 后日谈

唯有自救。

## 5 月 6 日

昨天晚上打 CF 去了，没写日记。

### [Needle in a Numstack](https://codeforces.com/problemset/problem/2108/D)

码力题。码力太强导致赛时没写出来。

### [Spruce Dispute](https://codeforces.com/problemset/problem/2108/E)

考虑如果已经删完点了如何求出最大的答案。我们考虑一个点 $u$。设它的子树大小是 $siz_u$，那么它的贡献就是 $siz_u \times (n - siz_u)$。为了最优，我们会让每一条路径都经过重心。因为重心的每个子节点 $v$ 所对应的子树大小 $siz_v$ 不会大于 $\frac{n}{2}$。于是顺理成章的把重心当成根，无根树就变成了有根树，总的答案就是每个点到根的距离之和。

但是这道题恶心的很，还要我们构造方案。我们发现构造方案主要是要满足重心的每一颗子树内没有颜色相同点，我们可以把 $u$ 的颜色设成 $tim \bmod \frac{n}{2}$，因为一颗子树的大小不会超过 $\frac{n}{2}$。

考虑删点。我们发现删掉一个点的代价是 $dep_u + siz_u - 1$，因为自己没贡献了，然后子树内的每个点深度还减了 $1$。经过一番推导，我们发现最优的点一定是深度最小的叶子节点。删了然后按照上面的方法构造即可。

### [Lost and Pound](https://atcoder.jp/contests/abc404/tasks/abc404_f?lang=en)

我们设 $dp_{i,j}$ 表示还有 $i$ 轮，还要按 $j$ 次胜利按钮的获胜概率，初始为 $dp_{0,0} = 1$。

我们发现，每次按完之后都会重新打乱，也就是说不存在知道获胜按钮的情况。于是我们就可以抛弃顺序，直接转移。设按了 $x$ 个按钮，每个按钮按了 $c_i$ 次，因为没有顺序，我们钦定 $c$ 单增。有转移：

$$
dp_{i,j} = \left( \sum\limits_{k = 1}^{x}dp_{i - 1,j - c_i} \right) + (n - x) \times dp_{i - 1,j}
$$

分别表示获胜按钮被按到了 $c_i$ 次或者压根没按到。

我们发现 $m$ 十分的小啊，可以直接枚举所有的 $c$。大概有 $5000$ 多个。加上枚举状态 $30^2$，时间复杂度 $O(\text{跑得过})$。

### [Removal of Multiples](https://atcoder.jp/contests/arc197/tasks/arc197_c?lang=en)

发现答案最多不会超过 $3 \times 10^6$，剩下的就是权值线段树的事了。

记得加上奇技淫巧小剪枝。

### [Ancestor Relation](https://atcoder.jp/contests/arc197/tasks/arc197_d?lang=en)

写日记的时候才发现昨天做了好多题。

想想怎么判无解。题目里说 $a_{i,j} = 1$ 时，$i,j$ 在一条从上往下的链上。而 $1$，作为根，肯定和所有的点都在一条链上。如果不是，就说明无解。还有：我们看，如果有 $a_i = a_j$，那么就说明 $a_i$ 和 $a_j$ 相对别的点的位置相同，可以得到他们在一条链上，也就是说必须有 $a_{i,j} = 1$，否则就无解。还有，如果有 $a_i \subseteq a_j$，那么就说明 $j$ 是 $i$ 的祖先，如果没有 $a_{i,j} = 1$，同样无解。

剩下的就全是有解的状态了。考虑两个点何时能够交换。发现当且仅当 $a_i = a_j$ 时能够交换。我们就可以把 $n$ 个点分成几个集合，$a$ 相同的在一个集合。每个集合的方案数就是 $siz!$，乘起来即可。

我们发现所有的操作都可以用 `bitset` 维护。所以时间复杂度 $O(\frac{n^3}{\omega})$，其中 $\omega$ 是 `bitset` 常数。

### [Apple Tree Traversing](https://codeforces.com/problemset/problem/2107/D)

码力依然强大。

我们发现“字典序最大”，而排在前面的又是长度，我们肯定是让长度最大。于是我们先取个直径。取完直径之后就分成了几个子树，递归处理即可，时间复杂度 $O(n \sqrt{n})$。

### [Cycling (Easy Version)](https://codeforces.com/problemset/problem/2107/F1)

我们设 $dp_i$ 表示跳到了 $i$ 后面还要多少代价才能跳到最前。初始有 $dp_0 = 0$。转移时考虑最后一个区间 $[j + 1,i]$。我们发现最优策略是把 $[j + 1,i]$ 里的最小值拿过来一直超，代价为 $(i - pos) + (i - j - 1) + val \times (i - j)$，分别表示把最小值掏过来，最小值跟着走，超最小值的总代价。于是我们拥有 $O(n^2)$ dp，可以通过简单版。

### [Cycling (Hard Version)](https://codeforces.com/problemset/problem/2107/F2)

不会 $O(n)$ 做法。

我们发现其实我们是可以确定区间的分界点的。比如我们拿一个样例：`4 1 3 2`。我们首先拿 $2$ 一直超。直到我们发现这里出现了一个 $1$。我们发现拿 $1$ 一直超比拿 $2$ 一直超更优。于是我们改拿 $1$ 一直超。我们把 $dp_i$ 的意义改一下，改成：先拿最后的一直超，直到现在超的比前一个数小，我们改拿前一个数继续超，如此循环往复。用此策略超到最前面的最小代价。显然，这玩意可以 $O(n)$ 预处理。

> 不懂策略的看过来\
> 比如 `4 1 3 2 5 3`，先拿 $3$ 一直超，直到我们看到了 $2$，就改拿 $2$ 继续超，然后我们又看到了 $1$，我们又改超 $1$。

那有人要问了：你没考虑把一段区间的最小值掏过来然后拿它一直超的情况啊？确实没考虑，所以我们现在考虑。依然是这个样例：`4 1 3 2 5 3`。假设我们现在在第 $6$ 个数后面。如果我们想把 $2$ 掏过来超，那么需要花费的代价是 $dp_4 + (6 - 4) \times 2 + 2 \times (6 - 4 - 1)$。每一项分别表示：已经走到 $2$ 所在的位置还需要的代价，$2$ 往返需要的代价，不停的超过 $2$ 需要的代价。

我们再推几组样例，会发现：如果我想把 $a_i$ 拿到 $j$ 的位置然后一直超，所需要的代价是 $dp_i + (j - i) \times 2 + (j - i - 1) \times a_i$。这玩意可以看做是一个关于 $j$ 的一次函数。总共 $n$ 个一次函数。我们把所有的一次函数都塞到一颗李超线段树里，然后每个位置的答案就是在这个位置查最小值。

### 05-04 T1

我居然记得去问？

首先有一个结论：如果上一层有 $x$ 个非叶子节点，上上层有 $y$ 个，那么这一层至多有 $x + y$ 个非叶子节点。因为每个点可以选择是当左儿子还是右儿子，分别代表上一层和上上层。

我们肯定是按照 $a$ 从大到小，深度从小到大填的。设 $dp_{d,i,x,y}$ 表示当前的深度为 $d$（这一层的叶子已经确定），一共有 $i$ 个点被钦定成了叶子，这一层还有 $x$ 个空位，下一层还有 $y$ 个空位。转移枚举下一层钦定 $t$ 个作为叶子：

$$
dp_{d,i,x,y} + (sum_{i + t} - sum_i) \times (d + 1) \to dp_{d + 1,i + t,y - t,x + y - t}
$$

我们发现 $d$ 其实是不必要的，状态改成 $dp_{i,x,y}$。依然是钦定这一层有 $t$ 个叶子：

$$
dp_{i,x,y} + (sum_n - sum_i) \to dp_{i + t,y - t,x + y - t}。
$$

之所以加的值从 $sum_{i + t} - sum_i$ 变成了 $sum_n - sum_i$，是因为最开始钦定所有的深度都为 $0$，转移时使一段后缀的深度 $+1$。

我们发现这依然是 $O(n^4)$ 的，跑不过。究其原因是转移是 $O(n)$ 的。考虑简化转移：

1. 再钦定一个点作为叶子：$dp_{i,x,y} \to dp_{i + 1,x - 1,y - 1}$。
2. 往下一层：$dp_{i,x,y} \to dp_{i,y,x + y}$。

于是转移就变成了 $O(1)$，总复杂度 $O(n^3)$。记得滚动数组优化空间。

> 关于 $dp_{i,x,y} \to dp_{i + 1,x - 1,y - 1}$\
> 因为本来就钦定的剩下的都在这一层，所以转移的时候不用加。$x,y$ 都 $-1$ 的原因是这一层少了一个，$x$ 自然要 $-1$。但是上一层又没变，所以 $y$ 也减了 $1$。

### 后日谈

才发现我这两天做了这么多题。

因为每次想要颓废的时候看到草神，就感觉颓废对不起自己，于是再切一道题。

**拼命练就的本领绝不会辜负自己。**

## 5 月 7 日

**你怎么敢在草神面前睡觉的？？？！！！**

还好还骗了 $105$ 分，不然今天就挂了。

### T1

大模拟。

$55$ 分做法：\
暴力枚举，时间复杂度 $O(n^2 m^2 k)$。

$100$ 分做法：\
发现只有有重叠的情况才需要特殊考虑。而这种情况又只有 $k^2$ 个，我们枚举这 $k^2$  种特殊情况就行，复杂度 $O(nmk^2)$。

### T2

感性理解：交换的 $i,j$ 一定是 $i < j$ 且 $a_i > a_j$ 的。我们设在 $(i,j)$ 区间内，大于 $a_i$ 的数有 $ma_i$ 个，小于 $a_i$ 的数有 $mi_i$ 个，$ma_j,mi_j$ 同理。那么交换 $i,j$ 会使逆序对数量减少 $mi_i - ma_i + ma_j - mi_j + 1$。移一下项变成 $mi_i - mi_j + ma_j - ma_i + 1$。我们发现这玩意就是区间 $k \in (i,j)$ 且 $a_k \in (a_j,a_i)$ 的个数乘 $2$。

我们把每个点塞到平面直角坐标系上面。第 $i$ 个额点的坐标是 $(i,a_i)$。那么上面的柿子就相当于：取一个左上角的点和一个右下角的点，它们框出来的矩形的里的点的数量（不包括边界）。使用扫描线维护。

如何使用扫描线维护？我们首先发现一个性质：如果有 $i < j$ 且 $a_i > a_j$，那么显然 $i$ 比 $j$ 优，$j$ 就不会成为“左上角的点”。言外之意：只有 $a_i = \max_{j = 1}^{i}a_j$，$i$ 才可能成为最优解里的“左上角的点”。